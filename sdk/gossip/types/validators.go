package types

import (
	"context"
	"fmt"

	"github.com/ipfs/go-cid"

	"github.com/quorumcontrol/chaintree/graftabledag"
	"github.com/quorumcontrol/chaintree/typecaster"

	"github.com/quorumcontrol/tupelo/sdk/consensus"

	"github.com/quorumcontrol/chaintree/chaintree"
	"github.com/quorumcontrol/chaintree/dag"
	"github.com/quorumcontrol/messages/v2/build/go/gossip"
	"github.com/quorumcontrol/messages/v2/build/go/transactions"
)

func init() {
	// Using this capital letter style to match the transactors (generated by protobufs)
	mustRegisterValidatorGenerator("ISOWNER", IsOwnerGenerator)
	mustRegisterValidatorGenerator("ISRECIPIENT", WrapStatelessValidator(IsTokenRecipient))
	mustRegisterValidatorGenerator("HASBURN", HasBurnGenerator)
}

func getReceiveTokenPayloads(txns []*transactions.Transaction) ([]*transactions.ReceiveTokenPayload, error) {
	receiveTokens := make([]*transactions.ReceiveTokenPayload, 0)
	for _, t := range txns {
		if t.Type == transactions.Transaction_RECEIVETOKEN {
			rt, err := t.EnsureReceiveTokenPayload()
			if err != nil {
				return nil, &consensus.ErrorCode{Code: consensus.ErrUnknown, Memo: fmt.Sprintf("error reading payload: %v", err)}
			}

			receiveTokens = append(receiveTokens, rt)
		}
	}
	return receiveTokens, nil
}

// Validator functions

// IsTokenRecipient is only applicable to RECEIVE_TOKEN transactions
// it checks whether the destination chaintree id matches our id or not
func IsTokenRecipient(tree *dag.Dag, blockWithHeaders *chaintree.BlockWithHeaders) (bool, chaintree.CodedError) {
	// first determine if there are any RECEIVE_TOKEN transactions in here
	receiveTokens, err := getReceiveTokenPayloads(blockWithHeaders.Transactions)
	if err != nil {
		return false, &consensus.ErrorCode{Code: consensus.ErrUnknown, Memo: fmt.Sprintf("error getting RECEIVE_TOKEN transactions: %v", err)}
	}

	if len(receiveTokens) == 0 {
		// if no RECEIVE_TOKEN transactions are present, short-circuit to valid
		return true, nil
	}

	// we have at least one RECEIVE_TOKEN; make sure it was intended for this chaintree

	id, _, err := tree.Resolve(context.TODO(), []string{"id"})
	if err != nil {
		return false, &consensus.ErrorCode{Memo: fmt.Sprintf("error: %v", err), Code: consensus.ErrUnknown}
	}

	for _, rt := range receiveTokens {
		senderDag, codedErr := consensus.GetSenderDagFromReceive(rt)
		if codedErr != nil {
			return false, codedErr
		}

		tokenName, codedErr := consensus.GetTokenNameFromReceive(senderDag)
		if codedErr != nil {
			return false, codedErr
		}

		sendToken, codedErr := consensus.GetSendTokenFromReceive(senderDag, tokenName)
		if codedErr != nil {
			return false, codedErr
		}

		if id.(string) != sendToken.Destination {
			return false, nil
		}
	}

	return true, nil
}

// GenerateHasValidProof is a higher-order function that takes a proof verifier
// function arg and returns a proof validator function (see below) that calls
// the given proof verifier with the Proof and Tip it receives and uses its
// return values to indicate validity.
func GenerateHasValidProof(proofVerifier func(proof *gossip.Proof) (bool, error)) chaintree.BlockValidatorFunc {
	//  return function that checks payloads with both Proof and Tip
	//  elements to verify that the Proof is indeed valid for Tip. It is
	//  currently used for RECEIVE_TOKEN transactions and so looks for them
	//  explicitly, but should be generalized to other transaction types
	//  that have similar Proof & Tip elements when/if they appear.
	return func(tree *dag.Dag, blockWithHeaders *chaintree.BlockWithHeaders) (bool, chaintree.CodedError) {
		// first determine if there any RECEIVE_TOKEN transactions in here
		receiveTokens, err := getReceiveTokenPayloads(blockWithHeaders.Transactions)
		if err != nil {
			return false, &consensus.ErrorCode{Code: consensus.ErrUnknown, Memo: fmt.Sprintf("error getting RECEIVE_TOKEN transactions: %v", err)}
		}

		if len(receiveTokens) == 0 {
			// if no RECEIVE_TOKEN transactions are present, short-circuit to valid
			return true, nil
		}

		// we have at least one RECEIVE_TOKEN transaction; make sure Proof is valid for Tip
		for _, rt := range receiveTokens {
			receiveProof := rt.Proof

			tip, err := cid.Cast(rt.Tip)
			if err != nil {
				return false, &consensus.ErrorCode{Code: consensus.ErrInvalidTip, Memo: fmt.Sprintf("error casting tip to CID: %v", err)}
			}

			proofTip, err := cid.Cast(receiveProof.Tip)
			if err != nil {
				return false, &consensus.ErrorCode{Code: consensus.ErrInvalidTip, Memo: fmt.Sprintf("error casting proof tip to CID: %v", err)}
			}

			if !proofTip.Equals(tip) {
				return false, nil
			}

			valid, err := proofVerifier(receiveProof)
			if err != nil {
				return false, &consensus.ErrorCode{Code: consensus.ErrUnknown, Memo: fmt.Sprintf("error verifying proof: %v", err)}
			}

			if !valid {
				return false, nil
			}
		}

		return true, nil
	}
}

func isTokenBurn(tokenName string, burnAmount uint64, tx *transactions.Transaction) bool {
	var amount uint64
	if burnAmount == 0 {
		amount = 1
	} else {
		amount = burnAmount
	}
	return tx.Type == transactions.Transaction_SENDTOKEN &&
		tx.SendTokenPayload.Name == tokenName &&
		tx.SendTokenPayload.Amount >= amount &&
		tx.SendTokenPayload.Destination == ""
}

// HasBurnGenerator is a higher-order generator (because we need notary group config for the token name) that returns a
// ChainTree validator that looks for the presence of a token burn in a block of transactions
// if the block has a transaction which has a SendToken with the config TransactionToken name,
// a value > 0 and a "" destination, it is considered a burn.
func HasBurnGenerator(ctx context.Context, ng *NotaryGroup) (chaintree.BlockValidatorFunc, error) {
	tokenName := ng.Config().TransactionToken
	if tokenName == "" {
		return nil, fmt.Errorf("error you must specify a TransactionCurrency to use the HasBurnGenerator")
	}

	burnAmount := ng.Config().BurnAmount

	var burnValidator chaintree.BlockValidatorFunc = func(tree *dag.Dag, blockWithHeaders *chaintree.BlockWithHeaders) (bool, chaintree.CodedError) {
		for _, tx := range blockWithHeaders.Block.Transactions {
			if isTokenBurn(tokenName, burnAmount, tx) {
				return true, nil
			}
		}
		return false, nil
	}
	return burnValidator, nil
}

// IsOwnerGenerator is a higher-order generator (because we need the notary group config in case
// any other chaintrees are owners of the one we're transacting on). It returns an IsOwner validator
// func.
// IsOwner is a chaintree BlockValidator that looks at the block headers and makes sure
// an authorized owner (an origin key addr, an addr in the consensus.TreePathForAuthentications path
// of this or any owning chaintree, or any other path that resolves to owner key addrs) has signed
// this block.
func IsOwnerGenerator(ctx context.Context, ng *NotaryGroup) (chaintree.BlockValidatorFunc, error) {
	dagGetter := ng.DagGetter

	var isOwnerValidator chaintree.BlockValidatorFunc = func(tree *dag.Dag, blockWithHeaders *chaintree.BlockWithHeaders) (bool, chaintree.CodedError) {
		return isOwner(ctx, dagGetter, tree, blockWithHeaders)
	}

	return isOwnerValidator, nil
}

func isOwner(ctx context.Context, dagGetter graftabledag.DagGetter, tree *dag.Dag, blockWithHeaders *chaintree.BlockWithHeaders) (bool, chaintree.CodedError) {
	headers := &consensus.StandardHeaders{}

	err := typecaster.ToType(blockWithHeaders.Headers, headers)
	if err != nil {
		return false, &consensus.ErrorCode{Memo: fmt.Sprintf("error: %v", err), Code: consensus.ErrUnknown}
	}

	gro, err := NewGraftedOwnership(tree, dagGetter)
	if err != nil {
		return false, &consensus.ErrorCode{Memo: fmt.Sprintf("error creating GraftedOwnership: %v", err), Code: consensus.ErrUnknown}
	}
	addrs, err := gro.ResolveOwners(ctx)
	if err != nil {
		return false, &consensus.ErrorCode{Memo: fmt.Sprintf("error resolving owners: %v", err), Code: consensus.ErrUnknown}
	}

	for _, auth := range addrs {
		isSigned, err := consensus.IsBlockSignedBy(ctx, blockWithHeaders, auth)
		if err != nil {
			return false, &consensus.ErrorCode{Memo: fmt.Sprintf("error finding if signed: %v", err), Code: consensus.ErrUnknown}
		}

		if isSigned {
			return true, nil
		}
	}

	return false, nil
}
